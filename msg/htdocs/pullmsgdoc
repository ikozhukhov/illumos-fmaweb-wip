#
# CDDL HEADER START
#
# The contents of this file are subject to the terms of the
# Common Development and Distribution License (the "License").
# You may not use this file except in compliance with the License.
#
# You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
# or http://www.opensolaris.org/os/licensing.
# See the License for the specific language governing permissions
# and limitations under the License.
#
# When distributing Covered Code, include this CDDL HEADER in each
# file and include the License file at usr/src/OPENSOLARIS.LICENSE.
# If applicable, add the following below this CDDL HEADER, with the
# fields enclosed by brackets "[]" replaced with your own identifying
# information: Portions Copyright [yyyy] [name of copyright owner]
#
# CDDL HEADER END
#

#
#ident	"@(#)pullmsgdoc	1.9	09/05/15 SMI"
#
# Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
# Use is subject to license terms.
#
# pullmsgdoc -- pull over msgdoc tree from event registry
#
# this script is run periodically via cron.
#
use strict;

umask 002;

# path to the gate's generated msgdoc tree
my $gatemsgdoc = '/net/dv11.sfbay/nfs2/dev/fma/gates/events-clone/generated/msgdoc';

# directory in which msgdoc directory resides
my $dest = '/data1/docs/cgi-bin/sun';

# what we call our backup copy of the msgdoc tree
my $omsgdoc = 'msgdoc.old.nopush';

# email address for results
my $mailto = 'events-diffs@sun.com';

# sendmail command used to send feedback
my $mailprog = '/usr/lib/sendmail -t -eq';

# checksum command to verify file contents
my $cksum = '/bin/cksum';

my ($beginsec,$beginmin,$beginhour) = localtime;
my $nfiles;
my $ncopy;
my $details;
my %gatesums;

my $line;
my $readme;
open(R, "$gatemsgdoc/README") or done("$gatemsgdoc/README: $!");
while (<R>) {
	$readme .= $_;
	$line++;
	last if /^Checksums:$/;
}
while (<R>) {
	$readme .= $_;
	$line++;
	chomp;
	next if /^$/;
	if (/^(\d+\s+\d+)\s+(.+)$/) {
		$gatesums{$2} = $1;
		$nfiles++;
	} else {
		done("$gatemsgdoc/README: $line: malformed entry \"$_\"");
	}
}
close(R);

done("no files found in $gatemsgdoc/README") unless $nfiles;

# blow away old backup copy and make new backup copy
if (-d "$dest/msgdoc") {
	# XXX don't bother with backup copy due to star-auth permissions
	# XXX issues.  besides, all the previous content is kept by the
	# XXX registry SCCS files...
	#$details .= docmd("/bin/rm -rf $dest/$omsgdoc") if -d "$dest/$omsgdoc";
	#$details .= docmd("/bin/cp -rp $dest/msgdoc $dest/$omsgdoc");
} else {
	# unlikely we'll get here, but just in case
	mkdir "$dest/msgdoc", 0775 or done("mkdir $dest/msgdoc: $!");
}

foreach my $path (keys %gatesums) {
	my $dirname;
	my $fname;

	if ($path =~ m,(.*)/(.*),) {
		$dirname = "$dest/msgdoc/$1";
		$fname = $2;
	} else {
		$dirname = "$dest/msgdoc";
		$fname = $path;
	}
	my $fullpath = "$dirname/$fname";

	if (-f $fullpath) {
		my $csum = `$cksum < $fullpath`;
		chomp($csum);
		next if $gatesums{$path} eq $csum;
		$details .= "Update file: $path\n";
	} else {
		$details .= "Create file: $path\n";
		$details .= docmd("/bin/mkdir -p $dirname");
	}

	# copy in new file
	$ncopy++;
	my $tempfullpath = "$dirname/.new$$.$fname";
	$details .= docmd("/bin/cp -p $gatemsgdoc/$path $tempfullpath");

	# verify copy has correct checksum
	my $ncsum = `$cksum < $tempfullpath`;
	chomp($ncsum);
	if ($gatesums{$path} ne $ncsum) {
		$details .=
		    "ERROR: copy of \"$path\" produced incorrect checksum: " .
		    "gate($gatesums{$path}) copy($ncsum)\n";
		next;
	}

	# generate diffs if this is an article
	$details .= dodiff("$dirname/$fname", "$dirname/.new$$.$fname")
	    if $dirname =~ /\.articles/ &&
	    -e "$dirname/$fname";

	# install new version
	rename "$dirname/.new$$.$fname", "$dirname/$fname" or
	    $details .= "ERROR: rename(\"$dirname/.new$$.$fname\", " .
	    \"$dirname/$fname\"): $!\n";
}

if ($ncopy) {
	# update the README file
	unlink("$dest/msgdoc/README") or
	    $details .= "ERROR: unlink $dest/msgdoc/README: $!\n";
	# best effort
	if (open(R, ">$dest/msgdoc/README")) {
		print R $readme;
		close(R);
		chmod 0444, "$dest/msgdoc/README";
	}
} else {
	$ncopy = 'None';
	# comment out next line if you want reports even when no diffs happen
	exit 0;
}
my ($endsec,$endmin,$endhour) = localtime;
my $begintm = sprintf('%02d:%02d:%02d', $beginhour,$beginmin,$beginsec);
my $endtm = sprintf('%02d:%02d:%02d', $endhour,$endmin,$endsec);

done(<<EOF);
        Start time: $begintm
          End time: $endtm

Checksums examined: $nfiles
      Files copied: $ncopy

$details
EOF

#
# done -- mail results and exit
#
sub done {
	my $msg = shift;

	# send the results in
	if (open(M, "|$mailprog")) {
		print M "To: $mailto\n";
		print M "Subject: pullmsgdoc results\n\n";
		print M $msg;
		print M "\n";
		close(M);
	} else {
		die "ERROR: $mailprog: $!\n";
	}
	exit 0;
}

#
# docmd -- run command, expecting no output (so any output is an error)
#
sub docmd {
	my $cmd = shift;
	local $/;
	my $results;

	open(CMD, "$cmd 2>\&1|") or return "ERROR: cannot run \"$cmd\": $!\n";
	$results = <CMD>;
	close(CMD);

	return $results;
}

#
# dodiff -- diff two files
#
sub dodiff {
	my $f1 = shift;
	my $f2 = shift;
	local $/;
	my $results;
	my $nlines;

	open(DIFF, "/bin/diff -w $f1 $f2 2>\&1|") or
	    return "ERROR: cannot run \"/bin/diff $f1 $f2\": $!\n";
	$results = <DIFF>;
	close(DIFF);

	$nlines++ while ($results =~ /\n/g);

	if ($nlines > 25) {
		$results = "($nlines-line diff not shown)\n";
	} else {
		$results .= "\n";
	}

	return $results;
}
